<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>HTTP权威指南 (图灵程序设计丛书)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos758505" class="calibre_"><span class="calibre3"><span class="bold">11.4　用户登录</span></span></p><p class="calibre_">Web 服务器无需被动地根据用户的 IP 地址来猜测他的身份，它可以要求用户通过用户名和密码进行认证（登录）来显式地询问用户是谁。</p><p class="calibre_">为了使 Web 站点的登录更加简便，HTTP 中包含了一种内建机制，可以用 <tt class="calibre8">WWW-Authenticate</tt> 首部和 <tt class="calibre8">Authorization</tt> 首部向 Web 站点传送用户的相关信息。一旦登录，浏览器就可以不断地在每条发往这个站点的请求中发送这个登录信息了，这样，就总是有登录信息可用了。我们将在第 12 章对这种 HTTP 认证机制进行更加详细的讨论，现在我们先来简单地看一看。</p><p class="calibre_">如果服务器希望在为用户提供对站点的访问之前，先行登录，可以向浏览器回送一条 HTTP 响应代码 401 Login Required。然后，浏览器会显示一个登录对话框，并用 <tt class="calibre8">Authorization</tt> 首部在下一条对服务器的请求中提供这些信息。<sup class="calibre4"><small class="calibre5"><span class="calibre6">1</span></small></sup> 图 11-2 对此进行了说明。</p><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">1 为了不让用户每发送一条请求都要登录一次，大多数浏览器都会记住某站点的登录信息，并将登录信息放在发送给该站点的每条请求中。</span></small></sup></p><p class="calibre_8"><img src="images/00050.jpg" class="calibre_25"/></p><p class="calibre_10"><span class="calibre7">图 11-2　用 HTTP 认证首部注册用户名</span></p><p class="calibre_">此图中发生的情况如下所述。</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">在图 11-2a 中，浏览器对站点 <a href="http://www.joes-hardware.com">www.joes-hardware.com</a> 发起了一条请求。</p></li><li value="2" class="calibre_7"><p class="calibre_">站点并不知道这个用户的身份，因此在图 11-2b 中，服务器会返回 401 Login Required HTTP 响应码，并添加 <tt class="calibre8">WWW-Authentication</tt> 首部，要求用户登录。这样浏览器就会弹出一个登录对话框。</p></li><li value="3" class="calibre_7"><p class="calibre_">只要用户输入了用户名和密码（对其身份进行完整性检查），浏览器就会重复原来的请求。这次它会添加一个 <tt class="calibre8">Authorization</tt> 首部，说明用户名和密码。对用户名和密码进行加密，防止那些有意无意的网络观察者看到。<sup class="calibre4"><small class="calibre5"><span class="calibre6">2</span></small></sup></p><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">2 在第 14 章我们会看到，任何有这种想法的人，不用费多大事就可以轻易地将 HTTP 基本的认证用户名和密码破解出来。稍后将讨论一些更安全的技术。</span></small></sup></p></li><li value="4" class="calibre_7"><p class="calibre_">现在，服务器已经知道用户的身份了。</p></li><li value="5" class="calibre_7"><p class="calibre_">今后的请求要使用用户名和密码时，浏览器会自动将存储下来的值发送出去，甚至在站点没有要求发送的时候也经常会向其发送。浏览器在每次请求中都向服务器发送 <tt class="calibre8">Authorization</tt> 首部作为一种身份的标识，这样，只要登录一次，就可以在整个会话期间维持用户的身份了。</p></li></ul><p class="calibre_">但是，登录多个 Web 站点是很繁琐的。Fred 从一个站点浏览到另一个站点的时候，需要在每个站点上登录。更糟的是，可怜的 Fred 很可能要为不同的站点记住不同的用户名和密码。他访问很多站点的时候，他最喜欢的用户名 fred 可能已经被其他人用过了，而且有些站点为用户名和密码的长度和组成设置了不同的规则。Fred 很快就会放弃上网，回去看奥普拉（Oprah）的脱口秀了。下一节我们来讨论这个问题的解决方案。</p><div class="mbp_pagebreak" id="calibre_pb_116"></div>
</body></html>
