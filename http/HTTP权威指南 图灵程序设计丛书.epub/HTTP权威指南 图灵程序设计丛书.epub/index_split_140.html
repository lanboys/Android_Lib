<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>HTTP权威指南 (图灵程序设计丛书)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos950491" class="calibre_"><span class="calibre3"><span class="bold">14.8　HTTPS 客户端实例</span></span></p><p class="calibre_">SSL 是个复杂的二进制协议。除非你是密码专家，否则就不应该直接发送原始的 SSL 流量。幸运的是，借助一些商业或开源的库，编写 SSL 客户端和服务器并不十分困难。</p><p class="calibre_8"><img src="images/00179.jpg" class="calibre_180"/></p><p class="calibre_10"><span class="calibre7">图 14-18　证书名不匹配引发的证书错误对话框</span></p><p class="calibre_"><span class="calibre3"><span class="bold">14.8.1　OpenSSL</span></span></p><p class="calibre_">OpenSSL 是 SSL 和 TLS 最常见的开源实现。OpenSSL 项目由一些志愿者合作开发，目标是开发一个强壮的、具有完备功能的商业级工具集，以实现 SSL 和 TLS 协议以及一个全功能的通用加密库。可以从 <a href="http://www.openssl.org">http://www.openssl.org</a> 上获得 OpenSSL 的相关信息，并下载相应软件。</p><p class="calibre_">你可能还听说过 SSLeay（读作 S-S-L-e-a-y）。OpenSSL 是 SSLeay 库的后继者，接口非常相似。SSLeay 最初是由 Eric A. Young（就是 SSLeay 中的“eay”）开发的。</p><p class="calibre_"><span class="calibre3"><span class="bold">14.8.2　简单的HTTPS客户端</span></span></p><p class="calibre_">本节我们将用 OpenSSL 包来编写一个非常初级的 HTTPS 客户端。这个客户端与服务器建立一条 SSL 连接，打印一些来自站点服务器的标识信息，通过安全信道发送 HTTP GET 请求，接收 HTTP 响应，并将响应打印出来。</p><p class="calibre_">下面显示的 C 程序是普通 HTTPS 客户端的 OpenSSL 实现。为了保持其简洁性，程序中没有包含差错处理和证书处理逻辑。</p><p class="calibre_">这个示例程序中删除了差错处理功能，所以只能将其用于示例。在一般的有差错存在的环境中，软件会崩溃或者无法正常运行。</p><blockquote class="calibre_21"><span class="calibre7"><tt class="calibre8">/**********************************************************************<br class="calibre2"/>* https_client.c --- very simple HTTPS client with no error checking<br class="calibre2"/>*      usage: https_client servername<br class="calibre2"/>**********************************************************************/<br class="calibre2"/><br class="calibre2"/>#include &lt;stdio.h&gt;<br class="calibre2"/>#include &lt;memory.h&gt;<br class="calibre2"/>#include &lt;errno.h&gt;<br class="calibre2"/>#include &lt;sys/types.h&gt;<br class="calibre2"/>#include &lt;sys/socket.h&gt;<br class="calibre2"/>#include &lt;netinet/in.h&gt;<br class="calibre2"/>#include &lt;arpa/inet.h&gt;<br class="calibre2"/>#include &lt;netdb.h&gt;<br class="calibre2"/><br class="calibre2"/>#include &lt;openssl/crypto.h&gt;<br class="calibre2"/>#include &lt;openssl/x509.h&gt;<br class="calibre2"/>#include &lt;openssl/pem.h&gt;<br class="calibre2"/>#include &lt;openssl/ssl.h&gt;<br class="calibre2"/>#include &lt;openssl/err.h&gt;<br class="calibre2"/><br class="calibre2"/>void main(int argc, char **argv)<br class="calibre2"/>{<br class="calibre2"/>    SSL *ssl;<br class="calibre2"/>    SSL_CTX *ctx;<br class="calibre2"/>    SSL_METHOD *client_method;<br class="calibre2"/>    X509 *server_cert;<br class="calibre2"/>    int sd,err;<br class="calibre2"/>    char *str,*hostname,outbuf[4096],inbuf[4096],host_header[512];<br class="calibre2"/>    struct hostent *host_entry;<br class="calibre2"/>    struct sockaddr_in server_socket_address;<br class="calibre2"/>    struct in_addr ip;<br class="calibre2"/><br class="calibre2"/>    /*========================================*/<br class="calibre2"/>    /* (1) initialize SSL library */<br class="calibre2"/>    /*========================================*/<br class="calibre2"/>    SSLeay_add_ssl_algorithms( );<br class="calibre2"/>    client_method = SSLv2_client_method( );<br class="calibre2"/>    SSL_load_error_strings( );<br class="calibre2"/>    ctx = SSL_CTX_new(client_method);<br class="calibre2"/>    printf("(1) SSL context initialized\n\n");<br class="calibre2"/>    /*=============================================*/<br class="calibre2"/>    /* (2) convert server hostname into IP address */<br class="calibre2"/>    /*=============================================*/<br class="calibre2"/><br class="calibre2"/>    hostname = argv[1];<br class="calibre2"/>    host_entry = gethostbyname(hostname);<br class="calibre2"/>    bcopy(host_entry-&gt;h_addr, &amp;(ip.s_addr), host_entry-&gt;h_length);<br class="calibre2"/><br class="calibre2"/>    printf("(2) '%s' has IP address '%s'\n\n", hostname, inet_ntoa(ip));<br class="calibre2"/>    /*=================================================*/<br class="calibre2"/>    /* (3) open a TCP connection to port 443 on server */<br class="calibre2"/>    /*=================================================*/<br class="calibre2"/><br class="calibre2"/>    sd = socket (AF_INET, SOCK_STREAM, 0);<br class="calibre2"/><br class="calibre2"/>    memset(&amp;server_socket_address, '\0', sizeof(server_socket_address));<br class="calibre2"/>    server_socket_address.sin_family = AF_INET;<br class="calibre2"/>    server_socket_address.sin_port = htons(443);<br class="calibre2"/>    memcpy(&amp;(server_socket_address.sin_addr.s_addr),<br class="calibre2"/>           host_entry-&gt;h_addr, host_entry-&gt;h_length);<br class="calibre2"/><br class="calibre2"/>    err = connect(sd, (struct sockaddr*) &amp;server_socket_address,<br class="calibre2"/>                 sizeof(server_socket_address));<br class="calibre2"/>    if (err &lt; 0) { perror("can't connect to server port"); exit(1); }<br class="calibre2"/><br class="calibre2"/>    printf("(3) TCP connection open to host '%s', port %d\n\n",<br class="calibre2"/>           hostname, server_socket_address.sin_port);<br class="calibre2"/><br class="calibre2"/>    /*========================================================*/<br class="calibre2"/>    /* (4) initiate the SSL handshake over the TCP connection */<br class="calibre2"/>    /*========================================================*/<br class="calibre2"/><br class="calibre2"/>    ssl = SSL_new(ctx);     /* create SSL stack endpoint */<br class="calibre2"/>    SSL_set_fd(ssl, sd);    /* attach SSL stack to socket */<br class="calibre2"/>    err = SSL_connect(ssl); /* initiate SSL handshake */<br class="calibre2"/><br class="calibre2"/>    printf("(4) SSL endpoint created &amp; handshake completed\n\n");<br class="calibre2"/><br class="calibre2"/>    /*============================================*/<br class="calibre2"/>    /* (5) print out the negotiated cipher chosen */<br class="calibre2"/>    /*============================================*/<br class="calibre2"/><br class="calibre2"/>    printf("(5) SSL connected with cipher: %s\n\n", SSL_get_cipher(ssl));<br class="calibre2"/><br class="calibre2"/>    /*========================================*/<br class="calibre2"/>    /* (6) print out the server's certificate */<br class="calibre2"/>    /*========================================*/<br class="calibre2"/><br class="calibre2"/>    server_cert = SSL_get_peer_certificate(ssl);<br class="calibre2"/>    printf("(6) server's certificate was received:\n\n");<br class="calibre2"/>    str = X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);<br class="calibre2"/>    printf("      subject: %s\n", str);<br class="calibre2"/>    str = X509_NAME_oneline(X509_get_issuer_name(server_cert), 0, 0);<br class="calibre2"/>    printf(" issuer: %s\n\n", str);<br class="calibre2"/><br class="calibre2"/>    /* certificate verification would happen here */<br class="calibre2"/><br class="calibre2"/>    X509_free(server_cert);<br class="calibre2"/><br class="calibre2"/>    /*********************************************************/<br class="calibre2"/>    /* (7) handshake complete --- send HTTP request over SSL */<br class="calibre2"/>    /*********************************************************/<br class="calibre2"/><br class="calibre2"/>    sprintf(host_header,"Host: %s:443\r\n",hostname);<br class="calibre2"/>    strcpy(outbuf,"GET / HTTP/1.0\r\n");<br class="calibre2"/>    strcat(outbuf,host_header);<br class="calibre2"/>    strcat(outbuf,"Connection: close\r\n");<br class="calibre2"/>    strcat(outbuf,"\r\n");<br class="calibre2"/><br class="calibre2"/>    err = SSL_write(ssl, outbuf, strlen(outbuf));<br class="calibre2"/>    shutdown (sd, 1); /* send EOF to server */<br class="calibre2"/><br class="calibre2"/>    printf("(7) sent HTTP request over encrypted channel:\n\n%s\n",outbuf);<br class="calibre2"/><br class="calibre2"/>    /**************************************************/<br class="calibre2"/>    /* (8) read back HTTP response from the SSL stack */<br class="calibre2"/>    /**************************************************/<br class="calibre2"/><br class="calibre2"/>    err = SSL_read(ssl, inbuf, sizeof(inbuf) - 1);<br class="calibre2"/>    inbuf[err] = '\0';<br class="calibre2"/>    printf ("(8) got back %d bytes of HTTP response:\n\n%s\n",err,inbuf);<br class="calibre2"/><br class="calibre2"/>    /************************************************/<br class="calibre2"/>    /* (9) all done, so close connection &amp; clean up */<br class="calibre2"/>    /************************************************/<br class="calibre2"/><br class="calibre2"/>    SSL_shutdown(ssl);<br class="calibre2"/>    close (sd);<br class="calibre2"/>    SSL_free (ssl);<br class="calibre2"/>    SSL_CTX_free (ctx);<br class="calibre2"/><br class="calibre2"/>    printf("(9) all done, cleaned up and closed connection\n\n");<br class="calibre2"/>}<br class="calibre2"/></tt></span></blockquote><p class="calibre_22">这个例子是在 Sun Solaris 上面编译运行的，但它说明了 SSL 在很多 OS 平台上的工作原理。由于 OpenSSL 提供了一些强有力的特性，包括所有加密、密钥以及证书管理在内的整个程序都可以在一个几页左右的 C 程序中实现。</p><p class="calibre_">下面按部分分析下这个程序。</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">程序的顶端包含了一些用于支持 TCP 联网和 SSL 的支撑文件。</p></li><li value="2" class="calibre_7"><p class="calibre_">第 1 部分通过调用 <tt class="calibre8">SSL_CTX_new</tt> 创建了本地上下文，以记录握手参数及与 SSL 连接有关的其他状态。</p></li><li value="3" class="calibre_7"><p class="calibre_">第 2 部分通过 Unix 的 <tt class="calibre8">gethostbyname</tt> 函数将（由一个命令行变元提供的）输入主机名转换成了 IP 地址。其他平台可能会通过其他方式来提供这项功能。</p></li><li value="4" class="calibre_7"><p class="calibre_">第 3 部分通过创建本地套接字、设置远端地址信息并连接到远端服务器，建立了一条到服务器端口 443 的 TCP 连接。</p></li><li value="5" class="calibre_7"><p class="calibre_">一旦 TCP 连接建立起来，就用 <tt class="calibre8">SSL_new</tt> 和 <tt class="calibre8">SSL_set_fd</tt> 将 SSL 层附加到 TCP 连接之上，并调用 <tt class="calibre8">SSL_connect</tt> 与服务器进行 SSL 握手。第 4 部分完成时，我们就建立了一个已选好密码且交换过证书的可运行的 SSL 信道。</p></li><li value="6" class="calibre_7"><p class="calibre_">第 5 部分打印了选中的批量加密密码值。</p></li><li value="7" class="calibre_7"><p class="calibre_">第 6 部分打印了服务器回送的 X.509 证书中包含的部分信息，其中包括与证书持有者和颁发证书的组织有关的信息。OpenSSL 库没有对服务器证书中的信息作任何特殊的处理。实际的 SSL 应用程序，比如 Web 浏览器会对证书进行一些完整性检查，以确保证书是正确签发的，且是来自正确主机的。我们在 14.7.6 节讨论了浏览器对服务器证书所做的处理。</p></li><li value="8" class="calibre_7"><p class="calibre_">此时，我们的 SSL 连接就已经可以用于安全数据的传输了。在第 7 部分中，用 <tt class="calibre8">SSL_write</tt> 在 SSL 信道上发送了简单的 HTTP 请求 GET / HTTP/1.0，然后关闭了连接的输出端。</p></li><li value="9" class="calibre_7"><p class="calibre_">在第 8 部分中，用 <tt class="calibre8">SSL_read</tt> 从连接上读回响应，并将其打印到屏幕上。SSL 层负责所有的加密和解密工作，因此可以直接读写普通的 HTTP 命令。</p></li><li value="10" class="calibre_7"><p class="calibre_">最后，在第 9 部分进行了一些清理工作。</p></li></ul><p class="calibre_">更多与 OpenSSL 库有关的信息请参见 <a href="http://www.openssl.org">http://www.openssl.org</a>。</p><p class="calibre_"><span class="calibre3"><span class="bold">14.8.3　执行OpenSSL客户端</span></span></p><p class="calibre_">下面显示了指向安全服务器时这个简单 HTTP 客户端的输出。在这个例子中，客户端指向了摩根士丹利的在线证券主页。在线交易公司都在广泛使用 HTTPS。</p><blockquote class="calibre_21"><span class="calibre7"><tt class="calibre8"><span class="bold">% https_client clients1.online.msdw.com</span></tt></span><span class="calibre7"><tt class="calibre8"><br class="calibre2"/>(1) SSL context initialized<br class="calibre2"/><br class="calibre2"/>(2) 'clients1.online.msdw.com' has IP address'63.151.15.11'<br class="calibre2"/><br class="calibre2"/>(3) TCP connection open to host 'clients1.online.msdw.com', port 443<br class="calibre2"/><br class="calibre2"/>(4) SSL endpoint created &amp; handshake completed<br class="calibre2"/><br class="calibre2"/>(5) SSL connected with cipher: DES-CBC3-MD5<br class="calibre2"/><br class="calibre2"/>(6) server's certificate was received:<br class="calibre2"/><br class="calibre2"/>      subject: /C=US/ST=Utah/L=Salt Lake City/O=Morgan Stanley/OU=Online/CN=<br class="calibre2"/>         clients1.online.msdw.com<br class="calibre2"/>      issuer: /C=US/O=RSA Data Security, Inc./OU=Secure Server Certification<br class="calibre2"/>         Authority<br class="calibre2"/>(7) sent HTTP request over encrypted channel:<br class="calibre2"/><br class="calibre2"/>GET / HTTP/1.0<br class="calibre2"/>Host: clients1.online.msdw.com:443<br class="calibre2"/>Connection: close<br class="calibre2"/><br class="calibre2"/>(8) got back 615 bytes of HTTP response:<br class="calibre2"/><br class="calibre2"/>HTTP/1.1 302 Found<br class="calibre2"/>Date: Sat, 09 Mar 2002 09:43:42 GMT<br class="calibre2"/>Server: Stronghold/3.0 Apache/1.3.14 RedHat/3013c (Unix) mod_ssl/2.7.1 OpenSSL/0.9.6<br class="calibre2"/>Location: https://clients.online.msdw.com/cgi-bin/ICenter/home<br class="calibre2"/>Connection: close<br class="calibre2"/>Content-Type: text/html; charset=iso-8859-1<br class="calibre2"/><br class="calibre2"/>&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;<br class="calibre2"/>&lt;HTML&gt;&lt;HEAD&gt;<br class="calibre2"/>&lt;TITLE&gt;302 Found&lt;/TITLE&gt;<br class="calibre2"/>&lt;/HEAD&gt;&lt;BODY&gt;<br class="calibre2"/>&lt;H1&gt;Found&lt;/H1&gt;<br class="calibre2"/>The document has moved &lt;A HREF="https://clients.online.msdw.com/cgi-bin/ICenter/<br class="calibre2"/>home"&gt;here&lt;/A&gt;.&lt;P&gt;<br class="calibre2"/>&lt;HR&gt;<br class="calibre2"/>&lt;ADDRESS&gt;Stronghold/3.0Apache/1.3.14 RedHat/3013c Server at clients1.online.msdw.com<br class="calibre2"/>Port 443&lt;/ADDRESS&gt;<br class="calibre2"/>&lt;/BODY&gt;&lt;/HTML&gt;<br class="calibre2"/><br class="calibre2"/>(9) all done, cleaned up and closed connection<br class="calibre2"/></tt></span></blockquote><p class="calibre_22">只要完成了前面 4 个部分，客户端就有了一条打开的 SSL 连接。这样它就可以查询连接的状态，选择参数，检查服务器证书了。</p><p class="calibre_">在这个例子中，客户端和服务器对 DES-CBC3-MD5 批量加密密码进行了沟通。你还能看到服务器站点证书属于美国犹他州盐湖城的摩根士丹利组织。证书由 RSA 数据安全组织授予，主机名为 <a href="http://clients1.online.msdw.com">clients1.online.msdw.com</a>，与请求相符。</p><p class="calibre_">只要建立起了 SSL 信道，并且客户端对站点的证书没有异议，就可以通过安全信道来发送其 HTTP 请求了。在我们这个例子中，客户端发送了一条简单的“GET / HTTP/1.0”HTTP 请求，并收到了 302 Redirect 响应，请求用户去获取另一个 URL。</p><div class="mbp_pagebreak" id="calibre_pb_140"></div>
</body></html>
