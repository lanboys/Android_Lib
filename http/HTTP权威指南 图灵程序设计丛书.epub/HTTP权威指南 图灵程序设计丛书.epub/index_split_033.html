<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>HTTP权威指南 (图灵程序设计丛书)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos177780" class="calibre_"><span class="calibre3"><span class="bold">3.3　方法</span></span></p><p class="calibre_">现在，我们对前面在表 3-1 中列出的一些基本 HTTP 方法进行更为深入的讨论。注 意，并不是每个服务器都实现了所有的方法。如果一台服务器要与 HTTP 1.1 兼容， 那么只要为其资源实现 GET 方法和 HEAD 方法就可以了。</p><p class="calibre_">即使服务器实现了所有这些方法，这些方法的使用很可能也是受限的。例如，支持 DELETE 方法或 PUT 方法（本节稍后介绍）的服务器可能并不希望任何人都能够删除或存储资源。这些限制通常都是在服务器的配置中进行设置的，因此会随着站点和服务器的不同而有所不同。</p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.1　安全方法</span></span></p><p class="calibre_">HTTP 定义了一组被称为<span class="bold">安全</span>方法的方法。GET 方法和 HEAD 方法都被认为是安全的，这就意味着使用 GET 或 HEAD 方法的 HTTP 请求都不会产生什么动作。</p><p class="calibre_">不产生动作，在这里意味着 HTTP 请求不会在服务器上产生什么结果。例如，你在 Joe 的五金商店购物时，点击了“提交购买”按钮。点击按钮时会提交一个带有信用卡信息的 POST 请求（稍后讨论），那么在服务器上，就会为你执行一个动作。在这种情况下，为购买行为支付信用卡就是所执行的动作。</p><p class="calibre_">安全方法并不一定是什么动作都不执行的（实际上，这是由 Web 开发者决定的）。使用安全方法的目的就是当使用可能引发某一动作的不安全方法时，允许HTTP应用程序开发者通知用户。在 Joe 的五金商店的例子中，你的 Web 浏览器可能会弹出一条警告消息，说明你正在用不安全的方法发起请求，这样可能会在服务器上引发一些事件（比如用你的信用卡支付费用）。</p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.2　GET</span></span></p><p class="calibre_">GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法。图 3-7 显示了一个例子，在这个例子中，客户端用 GET 方法发起了一次 HTTP 请求。</p><p class="calibre_8"><img src="images/00086.jpg" class="calibre_55"/></p><p class="calibre_10"><span class="calibre7">图 3-7　GET 示例</span></p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.3　HEAD</span></span></p><p class="calibre_">HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用 HEAD，可以：</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">在不获取资源的情况下了解资源的情况（比如，判断其类型）；</p></li><li value="2" class="calibre_7"><p class="calibre_">通过查看响应中的状态码，看看某个对象是否存在；</p></li><li value="3" class="calibre_7"><p class="calibre_">通过查看首部，测试资源是否被修改了。</p></li></ul><p class="calibre_">服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。遵循 HTTP/1.1 规范，就必须实现 HEAD 方法。图 3-8 显示了实际的 HEAD 方法。</p><p class="calibre_8"><img src="images/00073.jpg" class="calibre_56"/></p><p class="calibre_10"><span class="calibre7">图 3-8　HEAD 示例</span></p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.4　PUT</span></span></p><p class="calibre_">与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建 Web 页面，并用 PUT 直接将其安装到 Web 服务器上去（参见图 3-9）。</p><p class="calibre_8"><img src="images/00067.jpg" class="calibre_57"/></p><p class="calibre_10"><span class="calibre7">图 3-9　PUT 示例</span></p><p class="calibre_">PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它。</p><p class="calibre_">因为 PUT 允许用户对内容进行修改，所以很多 Web 服务器都要求在执行 PUT 之前，用密码登录。在第 12 章中可以读到更多有关密码认证的内容。</p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.5　POST</span></span></p><p class="calibre_">POST 方法起初是用来向服务器输入数据的 <sup class="calibre4"><small class="calibre5"><span class="calibre6">1</span></small></sup>。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。图 3-10 显示了一个用 POST 方法发起 HTTP 请求——向服务器发送表单数据——的客户端。</p><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">1 POST 用于向服务器发送数据。PUT 用于向服务器上的资源（例如文件）中存储数据。</span></small></sup></p><p class="calibre_8"><img src="images/00103.jpg" class="calibre_58"/></p><p class="calibre_10"><span class="calibre7">图 3-10　POST 示例</span></p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.6　TRACE</span></span></p><p class="calibre_">客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p><p class="calibre_">TRACE 请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过（参见图 3-11）。</p><p class="calibre_8"><img src="images/00082.jpg" class="calibre_59"/></p><p class="calibre_10"><span class="calibre7">图 3-11　TRACE 示例</span></p><p class="calibre_">TRACE 方法主要用于诊断；也就是说，用于验证请求是否如愿穿过了请求 / 响应链。它也是一种很好的工具，可以用来查看代理和其他应用程序对用户请求所产生效果。</p><p class="calibre_">尽管 TRACE 可以很方便地用于诊断，但它确实也有缺点，它假定中间应用程序对各种不同类型请求（不同的方法——GET、HEAD、POST等）的处理是相同的。很多 HTTP 应用程序会根据方法的不同做出不同的事情——比如，代理可能会将 POST 请求直接发送给服务器，而将 GET 请求发送给另一个 HTTP 应用程序（比如 Web 缓存）。TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对 TRACE 请求的处理方式。</p><p class="calibre_">TRACE 请求中不能带有实体的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.7　OPTIONS</span></span></p><p class="calibre_">OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）。</p><p class="calibre_">这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。图 3-12 显示了一个使用 OPTIONS 方法的请求。</p><p class="calibre_8"><img src="images/00097.jpg" class="calibre_9"/></p><p class="calibre_10"><span class="calibre7">图 3-12　OPTIONS 示例</span></p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.8　DELETE</span></span></p><p class="calibre_">顾名思义，DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。图 3-13 显示了一个 DELETE 方法实例。</p><p class="calibre_8"><img src="images/00090.jpg" class="calibre_60"/></p><p class="calibre_10"><span class="calibre7">图 3-13　DELETE 示例</span></p><p class="calibre_"><span class="calibre3"><span class="bold">3.3.9　扩展方法</span></span></p><p class="calibre_">HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法指的就是没有在 HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一些 HTTP 服务，这些方法为开发者提供了一种扩展这些 HTTP 服务能力的手段。表 3-5 列出了一些常见的扩展方法实例。这些方法就是 WebDAV HTTP 扩展（参见第 19 章）包含的所有方法，这些方法有助于通过 HTTP 将 Web 内容发布到 Web 服务 器上去。</p><p class="calibre_"><span class="bold">表3-5　Web发布扩展方法示例</span></p><p class="calibre2" style="margin:0pt; border:0pt; height:1em"> </p><table valign="top" class="calibre_14"><tr valign="top" class="calibre9"><th valign="top" class="calibre_34"><span class="calibre7"><span class="bold"> 方　　法 </span></span>
</th><th valign="top" class="calibre_46"><span class="calibre7"><span class="bold"> 描　　述 </span></span>
</th></tr><tr valign="top" class="calibre_17"><td valign="top" class="calibre10"><span class="calibre7"> LOCK </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> 允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人同时对其进行修改 </span><span class="calibre_18">
</span></td></tr><tr valign="top" class="calibre9"><td valign="top" class="calibre10"><span class="calibre7"> MKCOL </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> 允许用户创建资源 </span>
</td></tr><tr valign="top" class="calibre_17"><td valign="top" class="calibre10"><span class="calibre7"> COPY </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> 便于在服务器上复制资源 </span><span class="calibre_18">
</span></td></tr><tr valign="top" class="calibre9"><td valign="top" class="calibre10"><span class="calibre7"> MOVE </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> 在服务器上移动资源 </span>
</td></tr></table><p class="calibre_">并不是所有的扩展方法都是在正式规范中定义的，认识到这一点很重要。如果你定义了一个扩展方法，很可能大部分 HTTP 应用程序都无法理解。同样，你的 HTTP 应用程序也可能会遇到一些其他应用程序在用的，而它并不理解的扩展方法。</p><p class="calibre_">在这些情况下，最好对扩展方法宽容一些。如果能够在不破坏端到端行为的情况下将带有未知方法的报文传递给下游服务器的话，代理应尝试传递这些报文。如果可能破坏端到端行为，则应以 501 Not Implemented（无法实现）状态码进行响应。最好按惯例“对所发送的内容要求严一点，对所接收的内容宽容一些”来处理扩展方法（以及一般的 HTTP 扩展）。</p><div class="mbp_pagebreak" id="calibre_pb_33"></div>
</body></html>
