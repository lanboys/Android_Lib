<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>HTTP权威指南 (图灵程序设计丛书)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos1008278" class="calibre_"><span class="calibre3"><span class="bold">15.5　内容编码</span></span></p><p class="calibre_">HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接连上来的客户端之前 , 服务器可能会对它进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未经授权的第三方看到文档的内容。</p><p class="calibre_">这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码之后，编好码的数据就放在实体主体中，像往常一样发送给接收方。</p><p class="calibre_"><span class="calibre3"><span class="bold">15.5.1　内容编码过程</span></span></p><p class="calibre_">内容编码的过程如下所述。</p><div class="calibre_5"> </div><ol class="calibre_40"><li value="1" class="calibre_7"><p class="calibre_">网站服务器生成原始响应报文，其中有原始的 <tt class="calibre8">Content-Type</tt> 和 <tt class="calibre8">Content- Length</tt> 首部。</p></li><li value="2" class="calibre_7"><p class="calibre_">内容编码服务器（也可能就是原始的服务器或下行的代理）创建编码后的报文。编码后的报文有同样的 <tt class="calibre8">Content-Type</tt> 但 <tt class="calibre8">Content-Length</tt> 可能不同（比如主体被压缩了）。内容编码服务器在编码后的报文中增加 <tt class="calibre8">Content-Encoding</tt> 首部，这样接收的应用程序就可以进行解码了。</p></li><li value="3" class="calibre_7"><p class="calibre_">接收程序得到编码后的报文，进行解码，获得原始报文。</p></li></ol><p class="calibre_">图 15-3 给出了内容编码的梗概示例。</p><p class="calibre_8"><img src="images/00197.jpg" class="calibre_92"/></p><p class="calibre_10"><span class="calibre7">图 15-3　内容编码示例</span></p><p class="calibre_">在这个例子中，通过 gzip 内容编码函数对 HTML 页面处理之后，得到一个更小的、压缩的主体。经过网络发送的是压缩的主体，并打上了 gzip 压缩的标志。接收的客户端使用 gzip 解码器对实体进行解压缩。</p><p class="calibre_">下面给出的响应片段是另一个编码响应的例子（一个压缩的图像）：</p><blockquote class="calibre_21"><span class="calibre7"><tt class="calibre8">HTTP/1.1 200 OK<br class="calibre2"/>Date: Fri, 05 Nov 1999 22:35:15 GMT<br class="calibre2"/>Server: Apache/1.2.4<br class="calibre2"/>Content-Length: 6096<br class="calibre2"/>Content-Type: image/gif<br class="calibre2"/>Content-Encoding: gzip<br class="calibre2"/>[...]<br class="calibre2"/></tt></span></blockquote><p class="calibre_22">注意，<tt class="calibre8">Content-Type</tt> 首部可以且还应当出现在报文中。它说明了实体的原始格式，一旦实体被解码，要显示的时候，可能还是需要该信息才行的。记住，<tt class="calibre8">Content-Length</tt> 首部现在代表的是编码之后的主体长度。</p><p class="calibre_"><span class="calibre3"><span class="bold">15.5.2　内容编码类型</span></span></p><p class="calibre_">HTTP 定义了一些标准的内容编码类型，并允许用扩展编码的形式增添更多的编码。由互联网号码分配机构（IANA）对各种编码进行标准化，它给每个内容编码算法分配了唯一的代号。<tt class="calibre8">Content-Encoding</tt> 首部就用这些标准化的代号来说明编码时使用的算法。</p><p class="calibre_">表 15-2 列出了一些常用的内容编码代号。</p><p class="calibre_"><span class="bold">表15-2　内容编码代号</span></p><p class="calibre2" style="margin:0pt; border:0pt; height:1em"> </p><table valign="top" class="calibre_14"><tr valign="top" class="calibre9"><th valign="top" class="calibre_70"><span class="calibre7"><span class="bold"> </span></span><span class="calibre11"><tt class="calibre8"><span class="bold">Content-Encoding </span></tt></span><span class="calibre7"><span class="bold">值</span></span>
</th><th valign="top" class="calibre_44"><span class="calibre7"><span class="bold"> 描　　述 </span></span>
</th></tr><tr valign="top" class="calibre_17"><td valign="top" class="calibre10"><span class="calibre7"> gzip </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> 表明实体采用 GNU zip 编码<sup class="calibre14"><small class="calibre5"><span class="calibre13">a </span></small></sup></span><span class="calibre_18">
</span></td></tr><tr valign="top" class="calibre9"><td valign="top" class="calibre10"><span class="calibre7"> compress </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> 表明实体采用 Unix 的文件压缩程序 </span>
</td></tr><tr valign="top" class="calibre_17"><td valign="top" class="calibre10"><span class="calibre7"> deflate </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> 表明实体是用 zlib 的格式压缩的<sup class="calibre14"><small class="calibre5"><span class="calibre13">b </span></small></sup></span><span class="calibre_18">
</span></td></tr><tr valign="top" class="calibre9"><td valign="top" class="calibre10"><span class="calibre7"> identity </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> 表明没有对实体进行编码。当没有 </span><span class="calibre11"><tt class="calibre8">Content-Encoding </tt></span><span class="calibre7"> 首部时，就默认为这种情况</span>
</td></tr></table><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">a：RFC 1952 中说明了 gzip 编码。</span></small></sup></p><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">b：RFC 1950 和 1951 中讲解了 zlib 格式和 deflate 压缩算法。</span></small></sup></p><p class="calibre_">gzip、compress 以及 deflate 编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失。这些算法中，gzip 通常是效率最高的，使用最为广泛。</p><p class="calibre_"><span class="calibre3"><span class="bold">15.5.3　</span></span><span class="calibre3"><tt class="calibre8"><span class="bold">Accept-Encoding</span></tt></span><span class="calibre3"><span class="bold"> 首部</span></span></p><p class="calibre_">毫无疑问，我们不希望服务器用客户端无法解码的方式来对内容进行编码。为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放在请求的 <tt class="calibre8">Accept-Encoding</tt> 首部里发出去。如果 HTTP 请求中没有包含 <tt class="calibre8">Accept-Encoding</tt> 首部，服务器就可以假设客户端能够接受任何编码方式（等价于发送 <tt class="calibre8">Accept-Encoding: *</tt>）。</p><p class="calibre_">图 15-4 展示了 HTTP 事务中的 <tt class="calibre8">Accept-Encoding</tt> 首部。</p><p class="calibre_8"><img src="images/00077.jpg" class="calibre_177"/></p><p class="calibre_10"><span class="calibre7">图 15-4　展示了 HTTP 事务中的 </span><span class="calibre7"><tt class="calibre8">Accept-Encoding</tt></span><span class="calibre7"> 首部</span></p><p class="calibre_"><tt class="calibre8">Accept-Encoding</tt> 字段包含用逗号分隔的支持编码的列表，下面是一些例子：</p><blockquote class="calibre_21"><span class="calibre7"><tt class="calibre8">Accept-Encoding: compress, gzip<br class="calibre2"/>Accept-Encoding:<br class="calibre2"/>Accept-Encoding: *<br class="calibre2"/>Accept-Encoding: compress;q=0.5, gzip;q=1.0<br class="calibre2"/>Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0<br class="calibre2"/></tt></span></blockquote><p class="calibre_22">客户端可以给每种编码附带 Q（质量）值参数来说明编码的优先级。Q 值的范围从 0.0 到 1.0，0.0 说明客户端不想接受所说明的编码，1.0 则表明最希望使用的编码。“*”表示“任何其他方法”。决定在响应中回送什么内容给客户端是个更通用的过程，而选择使用何种内容编码则是此过程的一部分。第 17 章将详细讨论这个过程，以及 <tt class="calibre8">Content-Encoding</tt> 首部和 <tt class="calibre8">Accept-Encoding</tt> 首部。</p><p class="calibre_"><tt class="calibre8">identity</tt> 编码代号只能在 <tt class="calibre8">Accept-Encoding</tt> 首部中出现，客户端用它来说明相对于其他内容编码算法的优先级。 </p><div class="mbp_pagebreak" id="calibre_pb_149"></div>
</body></html>
