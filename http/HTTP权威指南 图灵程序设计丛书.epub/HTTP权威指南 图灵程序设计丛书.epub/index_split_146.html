<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>HTTP权威指南 (图灵程序设计丛书)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos986710" class="calibre_"><span class="calibre3"><span class="bold">15.2　Content-Length: 实体的大小</span></span></p><p class="calibre_"><tt class="calibre8">Content-Length</tt> 首部指示出报文中实体主体的字节大小。这个大小是包含了所有内容编码的，比如，对文本文件进行了 gzip 压缩的话，<tt class="calibre8">Content-Length</tt> 首部就是压缩后的大小，而不是原始大小。</p><p class="calibre_">除非使用了分块编码，否则 <tt class="calibre8">Content-Length</tt> 首部就是带有实体主体的报文必须使用的。使用 <tt class="calibre8">Content-Length</tt> 首部是为了能够检测出服务器崩溃而导致的报文截尾，并对共享持久连接的多个报文进行正确分段。</p><p class="calibre_"><span class="calibre3"><span class="bold">15.2.1　检测截尾</span></span></p><p class="calibre_">HTTP 的早期版本采用关闭连接的办法来划定报文的结束。但是，没有 <tt class="calibre8">Content-Length</tt> 的话，客户端无法区分到底是报文结束时正常的连接关闭，还是报文传输中由于服务器崩溃而导致的连接关闭。客户端需要通过 <tt class="calibre8">Content-Length</tt> 来检测报文截尾。</p><p class="calibre_">报文截尾的问题对缓存代理服务器来说尤其严重。如果缓存服务器收到被截尾的报文却没有识别出截尾的话，它可能会存储不完整的内容并多次使用它来提供服务。缓存代理服务器通常不会为没有显式 <tt class="calibre8">Content-Length</tt> 首部的 HTTP 主体做缓存，以此来减小缓存已截尾报文的风险。</p><p class="calibre_"><span class="calibre3"><span class="bold">15.2.2　错误的</span></span><span class="calibre3"><tt class="calibre8"><span class="bold">Content-Length</span></tt></span></p><p class="calibre_">错误的 <tt class="calibre8">Content-Length</tt> 比缺少 <tt class="calibre8">Content-Length</tt> 还要糟糕。因为某些早期的客户端和服务器在 <tt class="calibre8">Content-Length</tt> 计算上存在一些众所周知的错误，有些客户端、服务器以及代理中就包含了特别的算法，用来检测和纠正与有缺陷服务器的交互过程。HTTP/1.1 规定用户 Agent 代理应该在接收且检测到无效长度时通知用户。</p><p class="calibre_"><span class="calibre3"><span class="bold">15.2.3　</span></span><span class="calibre3"><tt class="calibre8"><span class="bold">Content-Length</span></tt></span><span class="calibre3"><span class="bold">与持久连接</span></span></p><p class="calibre_"><tt class="calibre8">Content-Length</tt> 首部对于持久连接是必不可少的。如果响应通过持久连接传送，就可能有另一条 HTTP 响应紧随其后。客户端通过 <tt class="calibre8">Content-Length</tt> 首部就可以知道报文在何处结束，下一条报文从何处开始。因为连接是持久的，客户端无法依赖连接关闭来判别报文的结束。如果没有 <tt class="calibre8">Content-Length</tt> 首部，HTTP 应用程序就不知道某个实体主体在哪里结束，下一条报文从哪里开始。</p><p class="calibre_">我们将在 15.6 节看到，有一种情况下，使用持久连接时可以没有 <tt class="calibre8">Content-Length</tt> 首部，即采用<span class="bold">分块编码</span>（chunked encoding）时。在分块编码的情况下，数据是分为一系列的块来发送的，每块都有大小说明。哪怕服务器在生成首部的时候不知道整个实体的大小（通常是因为实体是动态生成的），仍然可以使用分块编码传输若干已知大小的块。</p><p class="calibre_"><span class="calibre3"><span class="bold">15.2.4　内容编码</span></span></p><p class="calibre_">HTTP 允许对实体主体的内容进行编码，比如可以使之更安全或进行压缩以节省空间（本章稍后将详细解释压缩的问题）。如果主体进行了内容编码，<tt class="calibre8">Content-Length</tt> 首部说明的就是<span class="bold">编码后</span>（encoded）的主体的字节长度，而不是未编码的原始主体的长度。</p><p class="calibre_">某些 HTTP 应用程序在这方面搞错了，发送的是数据编码之前的大小，这会导致严重的错误，尤其是用在持久连接上。不幸的是，HTTP/1.1 规范中没有首部可以用来说明原始的、未编码的主体的长度，这就让客户端难以验证解码过程的完整性。<sup class="calibre4"><small class="calibre5"><span class="calibre6">1</span></small></sup></p><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">1 </span><span class="calibre6"><tt class="calibre8">Content-MD5</tt></span><span class="calibre6"> 首部也不行，它用来说明文档的 128 位 MD5 值，但这也是针对编码后的文档的。本章后面会说明 </span><span class="calibre6"><tt class="calibre8">Content-MD5</tt></span><span class="calibre6"> 首部。</span></small></sup></p><p class="calibre_"><span class="calibre3"><span class="bold">15.2.5　确定实体主体长度的规则</span></span></p><p class="calibre_">下面列出的规则说明了在若干不同的情况下如何正确计算主体的长度和结束位置。这些规则应当按顺序应用，谁先匹配就用谁。</p><div class="calibre_5"> </div><ol class="calibre_40"><li value="1" class="calibre_7"><p class="calibre_">如果特定的 HTTP 报文类型中不允许带有主体，就忽略 <tt class="calibre8">Content-Length</tt> 首部，它是对（没有实际发送出来的）主体进行计算的。这种情况下，<tt class="calibre8">Content-Length</tt> 首部是提示性的，并不说明实际的主体长度。（考虑不周的 HTTP 应用程序会认为有了 <tt class="calibre8">Content-Length</tt> 就有主体存在，这样就会出问题。）</p><p class="calibre_">最重要的例子就是 HEAD 响应。HEAD 方法请求服务器发送等价的 GET 请求中会出现的首部，但不要包括主体。因为对 GET 的响应会带有 <tt class="calibre8">Content-Length</tt> 首部，所以 HEAD 响应里面也有；但和 GET 响应不同的是，HEAD 响应中不会有主体。1XX、204 以及 304 响应也可以有提示性的 <tt class="calibre8">Content-Length</tt> 首部，但是也都没有实体主体。那些规定不能带有实体主体的报文，不管带有什么首部字段，都必须在首部之后的第一个空行终止。</p></li><li value="2" class="calibre_7"><p class="calibre_">如果报文中含有描述传输编码的 <tt class="calibre8">Transfer-Encoding</tt> 首部（不采用默认的 HTTP“恒等”编码），那实体就应由一个称为“零字节块”（zero-byte chunk）的特殊模式结束，除非报文已经因连接关闭而结束。我们将在本章后面讨论传输编码和分块编码。</p></li><li value="3" class="calibre_7"><p class="calibre_">如果报文中含有 <tt class="calibre8">Content-Length</tt> 首部（并且报文类型允许有实体主体），而且没有非恒等的 <tt class="calibre8">Transfer-Encoding</tt> 首部字段，那么 <tt class="calibre8">Content-Length</tt> 的值就是主体的长度。如果收到的报文中既有 <tt class="calibre8">Content-Length</tt> 首部字段又有非恒等的 <tt class="calibre8">Transfer-Encoding</tt> 首部字段，那就必须忽略 <tt class="calibre8">Content-Length</tt>，因为传输编码会改变实体主体的表示和传输方式（因此可能就会改变传输的字节数）。</p></li><li value="4" class="calibre_7"><p class="calibre_">如果报文使用了 multipart/byteranges（多部分 / 字节范围）媒体类型，并且没有用 <tt class="calibre8">Content-Length</tt> 首部指出实体主体的长度，那么多部分报文中的每个部分都要说明它自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。<sup class="calibre4"><small class="calibre5"><span class="calibre6">2</span></small></sup></p><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">2 因为 </span><span class="calibre6"><tt class="calibre8">Range</tt></span><span class="calibre6"> 首部可能会被不理解多部分 / 字节范围的更原始的代理所转发，所以如果发送方不能确定接收方是否理解这种自定界的格式的话，就必须用本节的方法1、3或5 来对报文定界。</span></small></sup></p></li><li value="5" class="calibre_7"><p class="calibre_">如果上面的规则都不匹配，实体就在连接关闭的时候结束。实际上，只有服务器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端报文的结束，因为这样会使服务器无法发回响应。<sup class="calibre4"><small class="calibre5"><span class="calibre6">3</span></small></sup></p><p class="calibre_"><sup class="calibre4"><small class="calibre5"><span class="calibre6">3 客户端可以使用半关闭，也就是只把连接的输出端关闭，但很多服务器应用程序设计的时候没有考虑到处理这种情况，会把半关闭当作客户端要从服务器断开连接来处理。HTTP 没有对连接管理进行良好的规范。详情请参见第 4 章。</span></small></sup></p></li></ol><p class="calibre_">为了和使用 HTTP/1.0 的应用程序兼容，任何带有实体主体的 HTTP/1.1 请求都必须带有正确的 <tt class="calibre8">Content-Length</tt> 首部字段（除非已经知道服务器兼容 HTTP/1.1）。HTTP/1.1 规范中建议对于带有主体但没有 <tt class="calibre8">Content-Length</tt> 首部的请求，服务器如果无法确定报文的长度，就应当发送 400 Bad Request 响应或 411 Length Required 响应，后一种情况表明服务器要求收到正确的 <tt class="calibre8">Content-Length</tt> 首部。</p><div class="mbp_pagebreak" id="calibre_pb_146"></div>
</body></html>
