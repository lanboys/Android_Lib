<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>HTTP权威指南 (图灵程序设计丛书)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="calibre_"><span class="calibre3"><span class="bold">E.3　Base-64填充</span></span></p><p class="calibre_">Base-64 编码收到一个 8 位字节序列，将这个二进制序列流划分成 6 位的块。二进制序列有时不能正好平均地分成 6 位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为 24 的倍数（6 和 8 的最小公倍数）。</p><p class="calibre_">对已填充的二进制串进行编码时，任何完全填充（不包含原始数据中的位）的 6 位组都由特殊的第 65 个符号“=”表示。如果 6 位组是部分填充的，就将填充位设置 为 0。</p><p class="calibre_">表 E-2 显示了一些填充实例。初始输入字符串“a:a”为 3 字节（24 位）。24 是 6 和 8 的倍数，因此无需填充，得到的 Base-64 编码字符串为“YTph”。</p><p class="calibre_"><span class="bold">表E-2　Base-64填充实例</span></p><p class="calibre2" style="margin:0pt; border:0pt; height:1em"> </p><table valign="top" class="calibre_14"><tr valign="top" class="calibre9"><th valign="top" class="calibre_34"><span class="calibre7"><span class="bold"> 输入数据 </span></span>
</th><th valign="top" class="calibre_35"><span class="calibre7"><span class="bold"> 二进制序列（填充位以x表示） </span></span>
</th><th valign="top" class="calibre_36"><span class="calibre7"><span class="bold"> 已编码数据 </span></span>
</th></tr><tr valign="top" class="calibre_17"><td valign="top" class="calibre10"><span class="calibre7"> a:a </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> 011000 010011 101001 100001 </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> YTph </span><span class="calibre_18">
</span></td></tr><tr valign="top" class="calibre9"><td valign="top" class="calibre10"><span class="calibre7"> a:aa </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> YTphYQ== </span>
</td></tr><tr valign="top" class="calibre_17"><td valign="top" class="calibre10"><span class="calibre7"> a:aaa </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> 011000 010011 101001 100001 011000 010110 0001xx xxxxxx </span><span class="calibre_18">
</span></td><td valign="top" class="calibre10"><span class="calibre7"> YTphYWE= </span><span class="calibre_18">
</span></td></tr><tr valign="top" class="calibre9"><td valign="top" class="calibre10"><span class="calibre7"> a:aaaa </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> 011000 010011 101001 100001 011000 010110 000101 100001 </span>
</td><td valign="top" class="calibre10"><span class="calibre7"> YTphYWFh </span>
</td></tr></table><p class="calibre_">然而，再增加一个字符，输入字符串会变成 32 位长。而 6 和 8 的下一个公倍数是 48，因此要添加 16 位的填充码。填充的前 4 位是与数据位混合在一起的。得到的 6 位组 01xxxx，会被当作 010000、十进制中的 16，或者 Base-64 编码的 Q 来处理。剩下的两个 6 位组都是填充码，用“=”表示。</p><div class="mbp_pagebreak" id="calibre_pb_217"></div>
</body></html>
